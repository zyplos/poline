{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/ban-ts-comment */\r\nexport type FuncNumberReturn = (arg0: number) => Vector2;\r\nexport type Vector2 = [number, number];\r\nexport type Vector3 = [number, ...Vector2];\r\nexport type PartialVector3 = [number | null, number | null, number | null];\r\n\r\ntype CSSColorMethods = {\r\n  hsl: (p: ColorPoint) => string;\r\n  oklch: (p: ColorPoint) => string;\r\n  lch: (p: ColorPoint) => string;\r\n};\r\n\r\n/**\r\n * Converts the given (x, y, z) coordinate to an HSL color\r\n * The (x, y) values are used to calculate the hue, while the z value is used as the saturation\r\n * The lightness value is calculated based on the distance of (x, y) from the center (0.5, 0.5)\r\n * Returns an array [hue, saturation, lightness]\r\n * @param xyz:Vector3 [x, y, z] coordinate array in (x, y, z) format (0-1, 0-1, 0-1)\r\n * @returns [hue, saturation, lightness]: Vector3 color array in HSL format (0-360, 0-1, 0-1)\r\n * @example\r\n * pointToHSL([0.5, 0.5, 1]) // [0, 1, 0.5]\r\n * pointToHSL([0.5, 0.5, 0]) // [0, 1, 0]\r\n **/\r\n\r\nexport const pointToHSL = (\r\n  xyz: Vector3,\r\n  invertedLightness: boolean\r\n): Vector3 => {\r\n  const [x, y, z] = xyz;\r\n\r\n  // cy and cx are the center (y and x) values\r\n  const cx = 0.5;\r\n  const cy = 0.5;\r\n\r\n  // Calculate the angle between the point (x, y) and the center (cx, cy)\r\n  const radians = Math.atan2(y - cy, x - cx);\r\n\r\n  // Convert the angle to degrees and shift it so that it goes from 0 to 360\r\n  let deg = radians * (180 / Math.PI);\r\n  deg = (360 + deg) % 360;\r\n\r\n  // The saturation value is taken from the z coordinate\r\n  const s = z;\r\n\r\n  // Calculate the lightness value based on the distance from the center\r\n  const dist = Math.sqrt(Math.pow(y - cy, 2) + Math.pow(x - cx, 2));\r\n  const l = dist / cx;\r\n\r\n  // Return the HSL color as an array [hue, saturation, lightness]\r\n  return [deg, s, invertedLightness ? 1 - l : l];\r\n};\r\n\r\n/**\r\n * Converts the given HSL color to an (x, y, z) coordinate\r\n * The hue value is used to calculate the (x, y) position, while the saturation value is used as the z coordinate\r\n * The lightness value is used to calculate the distance from the center (0.5, 0.5)\r\n * Returns an array [x, y, z]\r\n * @param hsl:Vector3 [hue, saturation, lightness] color array in HSL format (0-360, 0-1, 0-1)\r\n * @returns [x, y, z]:Vector3 coordinate array in (x, y, z) format (0-1, 0-1, 0-1)\r\n * @example\r\n * hslToPoint([0, 1, 0.5]) // [0.5, 0.5, 1]\r\n * hslToPoint([0, 1, 0]) // [0.5, 0.5, 1]\r\n * hslToPoint([0, 1, 1]) // [0.5, 0.5, 1]\r\n * hslToPoint([0, 0, 0.5]) // [0.5, 0.5, 0]\r\n **/\r\nexport const hslToPoint = (\r\n  hsl: Vector3,\r\n  invertedLightness: boolean\r\n): Vector3 => {\r\n  // Destructure the input array into separate hue, saturation, and lightness values\r\n  const [h, s, l] = hsl;\r\n  // cx and cy are the center (x and y) values\r\n  const cx = 0.5;\r\n  const cy = 0.5;\r\n  // Calculate the angle in radians based on the hue value\r\n  const radians = h / (180 / Math.PI);\r\n\r\n  // Calculate the distance from the center based on the lightness value\r\n  const dist = (invertedLightness ? 1 - l : l) * cx;\r\n\r\n  // Calculate the x and y coordinates based on the distance and angle\r\n  const x = cx + dist * Math.cos(radians);\r\n  const y = cy + dist * Math.sin(radians);\r\n  // The z coordinate is equal to the saturation value\r\n  const z = s;\r\n  // Return the (x, y, z) coordinate as an array [x, y, z]\r\n  return [x, y, z];\r\n};\r\n\r\nexport const randomHSLPair = (\r\n  startHue: number = Math.random() * 360,\r\n  saturations: Vector2 = [Math.random(), Math.random()],\r\n  lightnesses: Vector2 = [0.75 + Math.random() * 0.2, 0.3 + Math.random() * 0.2]\r\n): [Vector3, Vector3] => [\r\n  [startHue, saturations[0], lightnesses[0]],\r\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[1], lightnesses[1]],\r\n];\r\n\r\n/**\r\n * Clamps an (x, y) position to be within the color wheel circle\r\n * The circle has radius 0.5 centered at (0.5, 0.5)\r\n * If the point is outside the circle, it projects it to the edge\r\n * @param x The x coordinate (0-1)\r\n * @param y The y coordinate (0-1)\r\n * @returns [x, y] clamped to be within the circle\r\n * @example\r\n * clampToCircle(0.5, 0.5) // [0.5, 0.5] - center, unchanged\r\n * clampToCircle(1, 0.5) // [1, 0.5] - edge, unchanged\r\n * clampToCircle(1.5, 0.5) // [1, 0.5] - outside, clamped to edge\r\n */\r\nexport const clampToCircle = (x: number, y: number): Vector2 => {\r\n  const cx = 0.5;\r\n  const cy = 0.5;\r\n  const dx = x - cx;\r\n  const dy = y - cy;\r\n  const dist = Math.hypot(dx, dy);\r\n\r\n  if (dist <= 0.5) {\r\n    return [x, y];\r\n  }\r\n\r\n  // Project to edge of circle\r\n  return [cx + (dx / dist) * 0.5, cy + (dy / dist) * 0.5];\r\n};\r\n\r\nexport const randomHSLTriple = (\r\n  startHue: number = Math.random() * 360,\r\n  saturations: Vector3 = [Math.random(), Math.random(), Math.random()],\r\n  lightnesses: Vector3 = [\r\n    0.75 + Math.random() * 0.2,\r\n    Math.random() * 0.2,\r\n    0.75 + Math.random() * 0.2,\r\n  ]\r\n): [Vector3, Vector3, Vector3] => [\r\n  [startHue, saturations[0], lightnesses[0]],\r\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[1], lightnesses[1]],\r\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[2], lightnesses[2]],\r\n];\r\n\r\nconst vectorOnLine = (\r\n  t: number,\r\n  p1: Vector3,\r\n  p2: Vector3,\r\n  invert = false,\r\n  fx = (t: number, invert: boolean): number => (invert ? 1 - t : t),\r\n  fy = (t: number, invert: boolean): number => (invert ? 1 - t : t),\r\n  fz = (t: number, invert: boolean): number => (invert ? 1 - t : t)\r\n): Vector3 => {\r\n  const tModifiedX = fx(t, invert);\r\n  const tModifiedY = fy(t, invert);\r\n  const tModifiedZ = fz(t, invert);\r\n  const x = (1 - tModifiedX) * p1[0] + tModifiedX * p2[0];\r\n  const y = (1 - tModifiedY) * p1[1] + tModifiedY * p2[1];\r\n  const z = (1 - tModifiedZ) * p1[2] + tModifiedZ * p2[2];\r\n\r\n  return [x, y, z];\r\n};\r\n\r\nconst vectorsOnLine = (\r\n  p1: Vector3,\r\n  p2: Vector3,\r\n  numPoints = 4,\r\n  invert = false,\r\n  fx = (t: number, invert: boolean): number => (invert ? 1 - t : t),\r\n  fy = (t: number, invert: boolean): number => (invert ? 1 - t : t),\r\n  fz = (t: number, invert: boolean): number => (invert ? 1 - t : t)\r\n): Vector3[] => {\r\n  const points: Vector3[] = [];\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    const [x, y, z] = vectorOnLine(\r\n      i / (numPoints - 1),\r\n      p1,\r\n      p2,\r\n      invert,\r\n      fx,\r\n      fy,\r\n      fz\r\n    );\r\n    points.push([x, y, z]);\r\n  }\r\n\r\n  return points;\r\n};\r\n\r\nexport type PositionFunction = (t: number, reverse?: boolean) => number;\r\n\r\nconst linearPosition: PositionFunction = (t: number) => {\r\n  return t;\r\n};\r\n\r\nconst exponentialPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - (1 - t) ** 2;\r\n  }\r\n  return t ** 2;\r\n};\r\n\r\nconst quadraticPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - (1 - t) ** 3;\r\n  }\r\n  return t ** 3;\r\n};\r\n\r\nconst cubicPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - (1 - t) ** 4;\r\n  }\r\n  return t ** 4;\r\n};\r\n\r\nconst quarticPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - (1 - t) ** 5;\r\n  }\r\n  return t ** 5;\r\n};\r\n\r\nconst sinusoidalPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - Math.sin(((1 - t) * Math.PI) / 2);\r\n  }\r\n  return Math.sin((t * Math.PI) / 2);\r\n};\r\n\r\nconst asinusoidalPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - Math.asin(1 - t) / (Math.PI / 2);\r\n  }\r\n  return Math.asin(t) / (Math.PI / 2);\r\n};\r\n\r\nconst arcPosition: PositionFunction = (t: number, reverse = false) => {\r\n  if (reverse) {\r\n    return 1 - Math.sqrt(1 - t ** 2);\r\n  }\r\n  return 1 - Math.sqrt(1 - t);\r\n};\r\n\r\nconst smoothStepPosition: PositionFunction = (t: number) => {\r\n  return t ** 2 * (3 - 2 * t);\r\n};\r\n\r\nexport const positionFunctions = {\r\n  linearPosition,\r\n  exponentialPosition,\r\n  quadraticPosition,\r\n  cubicPosition,\r\n  quarticPosition,\r\n  sinusoidalPosition,\r\n  asinusoidalPosition,\r\n  arcPosition,\r\n  smoothStepPosition,\r\n};\r\n\r\n/**\r\n * Calculates the distance between two points\r\n * @param p1 The first point\r\n * @param p2 The second point\r\n * @param hueMode Whether to use the hue distance function\r\n * @returns The distance between the two points\r\n * @example\r\n * const p1 = [0, 0, 0];\r\n * const p2 = [1, 1, 1];\r\n * const dist = distance(p1, p2);\r\n * console.log(dist); // 1.7320508075688772\r\n **/\r\nconst distance = (\r\n  p1: PartialVector3,\r\n  p2: PartialVector3,\r\n  hueMode = false\r\n): number => {\r\n  const a1 = p1[0];\r\n  const a2 = p2[0];\r\n  let diffA = 0;\r\n\r\n  if (hueMode && a1 !== null && a2 !== null) {\r\n    diffA = Math.min(Math.abs(a1 - a2), 360 - Math.abs(a1 - a2));\r\n    diffA = diffA / 360;\r\n  } else {\r\n    diffA = a1 === null || a2 === null ? 0 : a1 - a2;\r\n  }\r\n\r\n  const a = diffA;\r\n  const b = p1[1] === null || p2[1] === null ? 0 : p2[1] - p1[1];\r\n  const c = p1[2] === null || p2[2] === null ? 0 : p2[2] - p1[2];\r\n\r\n  return Math.sqrt(a * a + b * b + c * c);\r\n};\r\n\r\nexport type ColorPointCollection = {\r\n  xyz?: Vector3;\r\n  color?: Vector3;\r\n  invertedLightness?: boolean;\r\n};\r\n\r\nexport class ColorPoint {\r\n  public x = 0;\r\n  public y = 0;\r\n  public z = 0;\r\n  public color: Vector3 = [0, 0, 0];\r\n  private _invertedLightness = false;\r\n\r\n  constructor({\r\n    xyz,\r\n    color,\r\n    invertedLightness = false,\r\n  }: ColorPointCollection = {}) {\r\n    this._invertedLightness = invertedLightness;\r\n    this.positionOrColor({ xyz, color, invertedLightness });\r\n  }\r\n\r\n  positionOrColor({\r\n    xyz,\r\n    color,\r\n    invertedLightness = false,\r\n  }: ColorPointCollection) {\r\n    this._invertedLightness = invertedLightness;\r\n    if ((xyz && color) || (!xyz && !color)) {\r\n      throw new Error(\"Point must be initialized with either x,y,z or hsl\");\r\n    } else if (xyz) {\r\n      this.x = xyz[0];\r\n      this.y = xyz[1];\r\n      this.z = xyz[2];\r\n      this.color = pointToHSL([this.x, this.y, this.z], invertedLightness);\r\n    } else if (color) {\r\n      this.color = color;\r\n      [this.x, this.y, this.z] = hslToPoint(color, invertedLightness);\r\n    }\r\n  }\r\n\r\n  set position([x, y, z]: Vector3) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n    this.color = pointToHSL(\r\n      [this.x, this.y, this.z] as Vector3,\r\n      this._invertedLightness\r\n    );\r\n  }\r\n\r\n  get position(): Vector3 {\r\n    return [this.x, this.y, this.z];\r\n  }\r\n\r\n  set hsl([h, s, l]: Vector3) {\r\n    this.color = [h, s, l];\r\n    [this.x, this.y, this.z] = hslToPoint(\r\n      this.color as Vector3,\r\n      this._invertedLightness\r\n    );\r\n  }\r\n\r\n  get hsl(): Vector3 {\r\n    return this.color;\r\n  }\r\n\r\n  get hslCSS(): string {\r\n    const [h, s, l] = this.color;\r\n    return `hsl(${h.toFixed(2)}, ${(s * 100).toFixed(2)}%, ${(l * 100).toFixed(\r\n      2\r\n    )}%)`;\r\n  }\r\n\r\n  get oklchCSS(): string {\r\n    const [h, s, l] = this.color;\r\n    return `oklch(${(l * 100).toFixed(2)}% ${(s * 0.4).toFixed(3)} ${h.toFixed(\r\n      2\r\n    )})`;\r\n  }\r\n\r\n  get lchCSS(): string {\r\n    const [h, s, l] = this.color;\r\n    return `lch(${(l * 100).toFixed(2)}% ${(s * 150).toFixed(2)} ${h.toFixed(\r\n      2\r\n    )})`;\r\n  }\r\n\r\n  set invertedLightness(val: boolean) {\r\n    this._invertedLightness = val;\r\n    this.color = pointToHSL(\r\n      [this.x, this.y, this.z] as Vector3,\r\n      this._invertedLightness\r\n    );\r\n  }\r\n\r\n  get invertedLightness(): boolean {\r\n    return this._invertedLightness;\r\n  }\r\n\r\n  shiftHue(angle: number): void {\r\n    this.color[0] = (360 + (this.color[0] + angle)) % 360;\r\n    [this.x, this.y, this.z] = hslToPoint(\r\n      this.color as Vector3,\r\n      this._invertedLightness\r\n    );\r\n  }\r\n}\r\n\r\nexport type PolineOptions = {\r\n  anchorColors?: Vector3[];\r\n  numPoints?: number;\r\n  positionFunction?: (t: number, invert?: boolean) => number;\r\n  positionFunctionX?: (t: number, invert?: boolean) => number;\r\n  positionFunctionY?: (t: number, invert?: boolean) => number;\r\n  positionFunctionZ?: (t: number, invert?: boolean) => number;\r\n  invertedLightness?: boolean;\r\n  closedLoop?: boolean;\r\n  clampToCircle?: boolean;\r\n};\r\nexport class Poline {\r\n  private _anchorPoints: ColorPoint[];\r\n\r\n  private _numPoints: number;\r\n  private points: ColorPoint[][];\r\n\r\n  private _positionFunctionX = sinusoidalPosition;\r\n  private _positionFunctionY = sinusoidalPosition;\r\n  private _positionFunctionZ = sinusoidalPosition;\r\n\r\n  private _anchorPairs: ColorPoint[][];\r\n\r\n  private connectLastAndFirstAnchor = false;\r\n\r\n  private _animationFrame: null | number = null;\r\n\r\n  private _invertedLightness = false;\r\n\r\n  private _clampToCircle = false;\r\n\r\n  constructor(\r\n    {\r\n      anchorColors = randomHSLPair(),\r\n      numPoints = 4,\r\n      positionFunction = sinusoidalPosition,\r\n      positionFunctionX,\r\n      positionFunctionY,\r\n      positionFunctionZ,\r\n      closedLoop,\r\n      invertedLightness,\r\n      clampToCircle,\r\n    }: PolineOptions = {\r\n      anchorColors: randomHSLPair(),\r\n      numPoints: 4,\r\n      positionFunction: sinusoidalPosition,\r\n      closedLoop: false,\r\n    }\r\n  ) {\r\n    if (!anchorColors || anchorColors.length < 2) {\r\n      throw new Error(\"Must have at least two anchor colors\");\r\n    }\r\n\r\n    this._anchorPoints = anchorColors.map(\r\n      (point) => new ColorPoint({ color: point, invertedLightness })\r\n    );\r\n\r\n    this._numPoints = numPoints + 2; // add two for the anchor points\r\n\r\n    this._positionFunctionX =\r\n      positionFunctionX || positionFunction || sinusoidalPosition;\r\n    this._positionFunctionY =\r\n      positionFunctionY || positionFunction || sinusoidalPosition;\r\n    this._positionFunctionZ =\r\n      positionFunctionZ || positionFunction || sinusoidalPosition;\r\n\r\n    this.connectLastAndFirstAnchor = closedLoop || false;\r\n\r\n    this._invertedLightness = invertedLightness || false;\r\n\r\n    this._clampToCircle = clampToCircle || false;\r\n\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get numPoints(): number {\r\n    return this._numPoints - 2;\r\n  }\r\n\r\n  public set numPoints(numPoints: number) {\r\n    if (numPoints < 1) {\r\n      throw new Error(\"Must have at least one point\");\r\n    }\r\n    this._numPoints = numPoints + 2; // add two for the anchor points\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public set positionFunction(\r\n    positionFunction: PositionFunction | PositionFunction[]\r\n  ) {\r\n    if (Array.isArray(positionFunction)) {\r\n      if (positionFunction.length !== 3) {\r\n        throw new Error(\"Position function array must have 3 elements\");\r\n      }\r\n      if (\r\n        typeof positionFunction[0] !== \"function\" ||\r\n        typeof positionFunction[1] !== \"function\" ||\r\n        typeof positionFunction[2] !== \"function\"\r\n      ) {\r\n        throw new Error(\"Position function array must have 3 functions\");\r\n      }\r\n      this._positionFunctionX = positionFunction[0];\r\n      this._positionFunctionY = positionFunction[1];\r\n      this._positionFunctionZ = positionFunction[2];\r\n    } else {\r\n      this._positionFunctionX = positionFunction;\r\n      this._positionFunctionY = positionFunction;\r\n      this._positionFunctionZ = positionFunction;\r\n    }\r\n\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get positionFunction(): PositionFunction | PositionFunction[] {\r\n    // not to sure what to do here, because the position function is a combination of the three\r\n    if (\r\n      this._positionFunctionX === this._positionFunctionY &&\r\n      this._positionFunctionX === this._positionFunctionZ\r\n    ) {\r\n      return this._positionFunctionX;\r\n    }\r\n\r\n    return [\r\n      this._positionFunctionX,\r\n      this._positionFunctionY,\r\n      this._positionFunctionZ,\r\n    ];\r\n  }\r\n\r\n  public set positionFunctionX(positionFunctionX: PositionFunction) {\r\n    this._positionFunctionX = positionFunctionX;\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get positionFunctionX(): PositionFunction {\r\n    return this._positionFunctionX;\r\n  }\r\n\r\n  public set positionFunctionY(positionFunctionY: PositionFunction) {\r\n    this._positionFunctionY = positionFunctionY;\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get positionFunctionY(): PositionFunction {\r\n    return this._positionFunctionY;\r\n  }\r\n\r\n  public set positionFunctionZ(positionFunctionZ: PositionFunction) {\r\n    this._positionFunctionZ = positionFunctionZ;\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get positionFunctionZ(): PositionFunction {\r\n    return this._positionFunctionZ;\r\n  }\r\n\r\n  public get clampToCircle(): boolean {\r\n    return this._clampToCircle;\r\n  }\r\n\r\n  public set clampToCircle(clamp: boolean) {\r\n    this._clampToCircle = clamp;\r\n  }\r\n\r\n  public get anchorPoints(): ColorPoint[] {\r\n    return this._anchorPoints;\r\n  }\r\n\r\n  public set anchorPoints(anchorPoints: ColorPoint[]) {\r\n    this._anchorPoints = anchorPoints;\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public updateAnchorPairs(): void {\r\n    this._anchorPairs = [] as ColorPoint[][];\r\n\r\n    const anchorPointsLength = this.connectLastAndFirstAnchor\r\n      ? this.anchorPoints.length\r\n      : this.anchorPoints.length - 1;\r\n\r\n    for (let i = 0; i < anchorPointsLength; i++) {\r\n      const pair = [\r\n        this.anchorPoints[i],\r\n        this.anchorPoints[(i + 1) % this.anchorPoints.length],\r\n      ] as ColorPoint[];\r\n\r\n      this._anchorPairs.push(pair);\r\n    }\r\n\r\n    this.points = this._anchorPairs.map((pair, i) => {\r\n      const p1position = pair[0] ? pair[0].position : ([0, 0, 0] as Vector3);\r\n      const p2position = pair[1] ? pair[1].position : ([0, 0, 0] as Vector3);\r\n\r\n      // Special handling for closed loop with exactly 2 anchors\r\n      // we want to invert the ease for the first segment\r\n      const shouldInvertEase = this.shouldInvertEaseForSegment(i);\r\n\r\n      return vectorsOnLine(\r\n        p1position,\r\n        p2position,\r\n        this._numPoints,\r\n        shouldInvertEase ? true : false,\r\n        this.positionFunctionX,\r\n        this.positionFunctionY,\r\n        this.positionFunctionZ\r\n      ).map(\r\n        (p) =>\r\n          new ColorPoint({ xyz: p, invertedLightness: this._invertedLightness })\r\n      );\r\n    });\r\n  }\r\n\r\n  public addAnchorPoint({\r\n    xyz,\r\n    color,\r\n    insertAtIndex,\r\n    clamp,\r\n  }: ColorPointCollection & {\r\n    insertAtIndex?: number;\r\n    clamp?: boolean;\r\n  }): ColorPoint {\r\n    let finalXyz = xyz;\r\n    const shouldClamp = clamp ?? this._clampToCircle;\r\n    if (shouldClamp && xyz) {\r\n      const [x, y, z] = xyz;\r\n      const [cx, cy] = clampToCircle(x, y);\r\n      finalXyz = [cx, cy, z];\r\n    }\r\n    const newAnchor = new ColorPoint({\r\n      xyz: finalXyz,\r\n      color,\r\n      invertedLightness: this._invertedLightness,\r\n    });\r\n    if (insertAtIndex !== undefined) {\r\n      this.anchorPoints.splice(insertAtIndex, 0, newAnchor);\r\n    } else {\r\n      this.anchorPoints.push(newAnchor);\r\n    }\r\n    this.updateAnchorPairs();\r\n    return newAnchor;\r\n  }\r\n\r\n  public removeAnchorPoint({\r\n    point,\r\n    index,\r\n  }: {\r\n    point?: ColorPoint;\r\n    index?: number;\r\n  }): void {\r\n    if (!point && index === undefined) {\r\n      throw new Error(\"Must provide a point or index\");\r\n    }\r\n\r\n    if (this.anchorPoints.length < 3) {\r\n      throw new Error(\"Must have at least two anchor points\");\r\n    }\r\n\r\n    let apid;\r\n\r\n    if (index !== undefined) {\r\n      apid = index;\r\n    } else if (point) {\r\n      apid = this.anchorPoints.indexOf(point);\r\n    }\r\n\r\n    if (apid > -1 && apid < this.anchorPoints.length) {\r\n      this.anchorPoints.splice(apid, 1);\r\n      this.updateAnchorPairs();\r\n    } else {\r\n      throw new Error(\"Point not found\");\r\n    }\r\n  }\r\n\r\n  public updateAnchorPoint({\r\n    point,\r\n    pointIndex,\r\n    xyz,\r\n    color,\r\n    clamp,\r\n  }: {\r\n    point?: ColorPoint;\r\n    pointIndex?: number;\r\n    clamp?: boolean;\r\n  } & ColorPointCollection): ColorPoint {\r\n    if (pointIndex !== undefined) {\r\n      point = this.anchorPoints[pointIndex];\r\n    }\r\n\r\n    if (!point) {\r\n      throw new Error(\"Must provide a point or pointIndex\");\r\n    }\r\n\r\n    if (!xyz && !color) {\r\n      throw new Error(\"Must provide a new xyz position or color\");\r\n    }\r\n\r\n    if (xyz) {\r\n      const shouldClamp = clamp ?? this._clampToCircle;\r\n      if (shouldClamp) {\r\n        const [x, y, z] = xyz;\r\n        const [cx, cy] = clampToCircle(x, y);\r\n        point.position = [cx, cy, z];\r\n      } else {\r\n        point.position = xyz;\r\n      }\r\n    }\r\n    if (color) point.hsl = color;\r\n\r\n    this.updateAnchorPairs();\r\n\r\n    return point;\r\n  }\r\n\r\n  public getClosestAnchorPoint({\r\n    xyz,\r\n    hsl,\r\n    maxDistance = 1,\r\n  }: {\r\n    xyz?: PartialVector3;\r\n    hsl?: PartialVector3;\r\n    maxDistance?: number;\r\n  }): ColorPoint | null {\r\n    if (!xyz && !hsl) {\r\n      throw new Error(\"Must provide a xyz or hsl\");\r\n    }\r\n\r\n    let distances;\r\n\r\n    if (xyz) {\r\n      distances = this.anchorPoints.map((anchor) =>\r\n        distance(anchor.position, xyz)\r\n      );\r\n    } else if (hsl) {\r\n      distances = this.anchorPoints.map((anchor) =>\r\n        distance(anchor.hsl, hsl, true)\r\n      );\r\n    }\r\n\r\n    const minDistance = Math.min(...distances);\r\n\r\n    if (minDistance > maxDistance) {\r\n      return null;\r\n    }\r\n\r\n    const closestAnchorIndex = distances.indexOf(minDistance);\r\n\r\n    return this.anchorPoints[closestAnchorIndex] || null;\r\n  }\r\n\r\n  public set closedLoop(newStatus: boolean) {\r\n    this.connectLastAndFirstAnchor = newStatus;\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get closedLoop(): boolean {\r\n    return this.connectLastAndFirstAnchor;\r\n  }\r\n\r\n  public set invertedLightness(newStatus: boolean) {\r\n    this._invertedLightness = newStatus;\r\n    this.anchorPoints.forEach((p) => (p.invertedLightness = newStatus));\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  public get invertedLightness(): boolean {\r\n    return this._invertedLightness;\r\n  }\r\n\r\n  /**\r\n   * Returns a flattened array of all points across all segments,\r\n   * removing duplicated anchor points at segment boundaries.\r\n   *\r\n   * Since anchor points exist at both the end of one segment and\r\n   * the beginning of the next, this method keeps only one instance of each.\r\n   * The filter logic keeps the first point (index 0) and then filters out\r\n   * points whose indices are multiples of the segment size (_numPoints),\r\n   * which are the anchor points at the start of each segment (except the first).\r\n   *\r\n   * This approach ensures we get all unique points in the correct order\r\n   * while avoiding duplicated anchor points.\r\n   *\r\n   * @returns {ColorPoint[]} A flat array of unique ColorPoint instances\r\n   */\r\n  public get flattenedPoints() {\r\n    return this.points\r\n      .flat()\r\n      .filter((p, i) => (i != 0 ? i % this._numPoints : true));\r\n  }\r\n\r\n  public get colors() {\r\n    const colors = this.flattenedPoints.map((p) => p.color);\r\n    if (this.connectLastAndFirstAnchor && this._anchorPoints.length !== 2) {\r\n      colors.pop();\r\n    }\r\n    return colors;\r\n  }\r\n\r\n  public cssColors(mode: \"hsl\" | \"oklch\" | \"lch\" = \"hsl\"): string[] {\r\n    const methods: CSSColorMethods = {\r\n      hsl: (p: ColorPoint): string => p.hslCSS,\r\n      oklch: (p: ColorPoint): string => p.oklchCSS,\r\n      lch: (p: ColorPoint): string => p.lchCSS,\r\n    };\r\n    const cssColors = this.flattenedPoints.map(methods[mode]);\r\n    if (this.connectLastAndFirstAnchor) {\r\n      cssColors.pop();\r\n    }\r\n    return cssColors;\r\n  }\r\n\r\n  public get colorsCSS() {\r\n    return this.cssColors(\"hsl\");\r\n  }\r\n\r\n  public get colorsCSSlch() {\r\n    return this.cssColors(\"lch\");\r\n  }\r\n\r\n  public get colorsCSSoklch() {\r\n    return this.cssColors(\"oklch\");\r\n  }\r\n\r\n  public shiftHue(hShift = 20): void {\r\n    this.anchorPoints.forEach((p) => p.shiftHue(hShift));\r\n    this.updateAnchorPairs();\r\n  }\r\n\r\n  /**\r\n   * Returns a color at a specific position along the entire color line (0-1)\r\n   * Treats all segments as one continuous path, respecting easing functions\r\n   * @param t Position along the line (0-1), where 0 is start and 1 is end\r\n   * @returns ColorPoint at the specified position\r\n   * @example\r\n   * getColorAt(0) // Returns color at the very beginning\r\n   * getColorAt(0.5) // Returns color at the middle of the entire journey\r\n   * getColorAt(1) // Returns color at the very end\r\n   */\r\n  public getColorAt(t: number): ColorPoint {\r\n    if (t < 0 || t > 1) {\r\n      throw new Error(\"Position must be between 0 and 1\");\r\n    }\r\n\r\n    if (this.anchorPoints.length === 0) {\r\n      throw new Error(\"No anchor points available\");\r\n    }\r\n\r\n    // For closed loops, we need to handle the full circle\r\n    const totalSegments = this.connectLastAndFirstAnchor\r\n      ? this.anchorPoints.length\r\n      : this.anchorPoints.length - 1;\r\n\r\n    // Special case: if we only have 2 anchors in a closed loop,\r\n    // we actually have 2 segments going different ways\r\n    const effectiveSegments =\r\n      this.connectLastAndFirstAnchor && this.anchorPoints.length === 2\r\n        ? 2\r\n        : totalSegments;\r\n\r\n    // Calculate which segment we're in and the position within that segment\r\n    const segmentPosition = t * effectiveSegments;\r\n    const segmentIndex = Math.floor(segmentPosition);\r\n    const localT = segmentPosition - segmentIndex;\r\n\r\n    // Handle edge case where t = 1 (end of line)\r\n    const actualSegmentIndex =\r\n      segmentIndex >= effectiveSegments ? effectiveSegments - 1 : segmentIndex;\r\n    const actualLocalT = segmentIndex >= effectiveSegments ? 1 : localT;\r\n\r\n    // Get the anchor pair for this segment\r\n    const pair = this._anchorPairs[actualSegmentIndex];\r\n    if (!pair || pair.length < 2 || !pair[0] || !pair[1]) {\r\n      // Fallback to first anchor if something goes wrong\r\n      return new ColorPoint({\r\n        color: this.anchorPoints[0]?.color || [0, 0, 0],\r\n        invertedLightness: this._invertedLightness,\r\n      });\r\n    }\r\n\r\n    const p1position = pair[0].position;\r\n    const p2position = pair[1].position;\r\n\r\n    // Apply the same easing logic as in updateAnchorPairs\r\n    const shouldInvertEase =\r\n      this.shouldInvertEaseForSegment(actualSegmentIndex);\r\n\r\n    // Use the existing vectorOnLine function for consistent interpolation\r\n    const xyz = vectorOnLine(\r\n      actualLocalT,\r\n      p1position,\r\n      p2position,\r\n      shouldInvertEase,\r\n      this._positionFunctionX,\r\n      this._positionFunctionY,\r\n      this._positionFunctionZ\r\n    );\r\n\r\n    return new ColorPoint({\r\n      xyz,\r\n      invertedLightness: this._invertedLightness,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Determines whether easing should be inverted for a given segment\r\n   * @param segmentIndex The index of the segment\r\n   * @returns Whether easing should be inverted\r\n   */\r\n  private shouldInvertEaseForSegment(segmentIndex: number): boolean {\r\n    return !!(\r\n      segmentIndex % 2 ||\r\n      (this.connectLastAndFirstAnchor &&\r\n        this.anchorPoints.length === 2 &&\r\n        segmentIndex === 0)\r\n    );\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst { p5 } = globalThis as any;\r\n\r\nif (p5 && p5.VERSION && p5.VERSION.startsWith(\"1.\")) {\r\n  console.info(\"p5 < 1.x detected, adding poline to p5 prototype\");\r\n\r\n  const poline = new Poline();\r\n  p5.prototype.poline = poline;\r\n\r\n  const polineColors = () =>\r\n    poline.colors.map(\r\n      (c) => `hsl(${Math.round(c[0])},${c[1] * 100}%,${c[2] * 100}%)`\r\n    );\r\n\r\n  p5.prototype.registerMethod(\"polineColors\", polineColors);\r\n\r\n  globalThis.poline = poline;\r\n  globalThis.polineColors = polineColors;\r\n}\r\n"],
  "mappings": ";AAwBO,IAAM,aAAa,CACxB,KACA,sBACY;AACZ,QAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAGlB,QAAM,KAAK;AACX,QAAM,KAAK;AAGX,QAAM,UAAU,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE;AAGzC,MAAI,MAAM,WAAW,MAAM,KAAK;AAChC,SAAO,MAAM,OAAO;AAGpB,QAAM,IAAI;AAGV,QAAM,OAAO,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC;AAChE,QAAM,IAAI,OAAO;AAGjB,SAAO,CAAC,KAAK,GAAG,oBAAoB,IAAI,IAAI,CAAC;AAC/C;AAeO,IAAM,aAAa,CACxB,KACA,sBACY;AAEZ,QAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAElB,QAAM,KAAK;AACX,QAAM,KAAK;AAEX,QAAM,UAAU,KAAK,MAAM,KAAK;AAGhC,QAAM,QAAQ,oBAAoB,IAAI,IAAI,KAAK;AAG/C,QAAM,IAAI,KAAK,OAAO,KAAK,IAAI,OAAO;AACtC,QAAM,IAAI,KAAK,OAAO,KAAK,IAAI,OAAO;AAEtC,QAAM,IAAI;AAEV,SAAO,CAAC,GAAG,GAAG,CAAC;AACjB;AAEO,IAAM,gBAAgB,CAC3B,WAAmB,KAAK,OAAO,IAAI,KACnC,cAAuB,CAAC,KAAK,OAAO,GAAG,KAAK,OAAO,CAAC,GACpD,cAAuB,CAAC,OAAO,KAAK,OAAO,IAAI,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG,MACtD;AAAA,EACvB,CAAC,UAAU,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAAA,EACzC,EAAE,WAAW,KAAK,KAAK,OAAO,IAAI,OAAO,KAAK,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAC9E;AAcO,IAAM,gBAAgB,CAAC,GAAW,MAAuB;AAC9D,QAAM,KAAK;AACX,QAAM,KAAK;AACX,QAAM,KAAK,IAAI;AACf,QAAM,KAAK,IAAI;AACf,QAAM,OAAO,KAAK,MAAM,IAAI,EAAE;AAE9B,MAAI,QAAQ,KAAK;AACf,WAAO,CAAC,GAAG,CAAC;AAAA,EACd;AAGA,SAAO,CAAC,KAAM,KAAK,OAAQ,KAAK,KAAM,KAAK,OAAQ,GAAG;AACxD;AAEO,IAAM,kBAAkB,CAC7B,WAAmB,KAAK,OAAO,IAAI,KACnC,cAAuB,CAAC,KAAK,OAAO,GAAG,KAAK,OAAO,GAAG,KAAK,OAAO,CAAC,GACnE,cAAuB;AAAA,EACrB,OAAO,KAAK,OAAO,IAAI;AAAA,EACvB,KAAK,OAAO,IAAI;AAAA,EAChB,OAAO,KAAK,OAAO,IAAI;AACzB,MACgC;AAAA,EAChC,CAAC,UAAU,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAAA,EACzC,EAAE,WAAW,KAAK,KAAK,OAAO,IAAI,OAAO,KAAK,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAAA,EAC5E,EAAE,WAAW,KAAK,KAAK,OAAO,IAAI,OAAO,KAAK,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAC9E;AAEA,IAAM,eAAe,CACnB,GACA,IACA,IACA,SAAS,OACT,KAAK,CAACA,IAAWC,YAA6BA,UAAS,IAAID,KAAIA,IAC/D,KAAK,CAACA,IAAWC,YAA6BA,UAAS,IAAID,KAAIA,IAC/D,KAAK,CAACA,IAAWC,YAA6BA,UAAS,IAAID,KAAIA,OACnD;AACZ,QAAM,aAAa,GAAG,GAAG,MAAM;AAC/B,QAAM,aAAa,GAAG,GAAG,MAAM;AAC/B,QAAM,aAAa,GAAG,GAAG,MAAM;AAC/B,QAAM,KAAK,IAAI,cAAc,GAAG,CAAC,IAAI,aAAa,GAAG,CAAC;AACtD,QAAM,KAAK,IAAI,cAAc,GAAG,CAAC,IAAI,aAAa,GAAG,CAAC;AACtD,QAAM,KAAK,IAAI,cAAc,GAAG,CAAC,IAAI,aAAa,GAAG,CAAC;AAEtD,SAAO,CAAC,GAAG,GAAG,CAAC;AACjB;AAEA,IAAM,gBAAgB,CACpB,IACA,IACA,YAAY,GACZ,SAAS,OACT,KAAK,CAAC,GAAWC,YAA6BA,UAAS,IAAI,IAAI,GAC/D,KAAK,CAAC,GAAWA,YAA6BA,UAAS,IAAI,IAAI,GAC/D,KAAK,CAAC,GAAWA,YAA6BA,UAAS,IAAI,IAAI,MACjD;AACd,QAAM,SAAoB,CAAC;AAE3B,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,UAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAAA,MAChB,KAAK,YAAY;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,EACvB;AAEA,SAAO;AACT;AAIA,IAAM,iBAAmC,CAAC,MAAc;AACtD,SAAO;AACT;AAEA,IAAM,sBAAwC,CAAC,GAAW,UAAU,UAAU;AAC5E,MAAI,SAAS;AACX,WAAO,KAAK,IAAI,MAAM;AAAA,EACxB;AACA,SAAO,KAAK;AACd;AAEA,IAAM,oBAAsC,CAAC,GAAW,UAAU,UAAU;AAC1E,MAAI,SAAS;AACX,WAAO,KAAK,IAAI,MAAM;AAAA,EACxB;AACA,SAAO,KAAK;AACd;AAEA,IAAM,gBAAkC,CAAC,GAAW,UAAU,UAAU;AACtE,MAAI,SAAS;AACX,WAAO,KAAK,IAAI,MAAM;AAAA,EACxB;AACA,SAAO,KAAK;AACd;AAEA,IAAM,kBAAoC,CAAC,GAAW,UAAU,UAAU;AACxE,MAAI,SAAS;AACX,WAAO,KAAK,IAAI,MAAM;AAAA,EACxB;AACA,SAAO,KAAK;AACd;AAEA,IAAM,qBAAuC,CAAC,GAAW,UAAU,UAAU;AAC3E,MAAI,SAAS;AACX,WAAO,IAAI,KAAK,KAAM,IAAI,KAAK,KAAK,KAAM,CAAC;AAAA,EAC7C;AACA,SAAO,KAAK,IAAK,IAAI,KAAK,KAAM,CAAC;AACnC;AAEA,IAAM,sBAAwC,CAAC,GAAW,UAAU,UAAU;AAC5E,MAAI,SAAS;AACX,WAAO,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;AAAA,EAC3C;AACA,SAAO,KAAK,KAAK,CAAC,KAAK,KAAK,KAAK;AACnC;AAEA,IAAM,cAAgC,CAAC,GAAW,UAAU,UAAU;AACpE,MAAI,SAAS;AACX,WAAO,IAAI,KAAK,KAAK,IAAI,KAAK,CAAC;AAAA,EACjC;AACA,SAAO,IAAI,KAAK,KAAK,IAAI,CAAC;AAC5B;AAEA,IAAM,qBAAuC,CAAC,MAAc;AAC1D,SAAO,KAAK,KAAK,IAAI,IAAI;AAC3B;AAEO,IAAM,oBAAoB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAcA,IAAM,WAAW,CACf,IACA,IACA,UAAU,UACC;AACX,QAAM,KAAK,GAAG,CAAC;AACf,QAAM,KAAK,GAAG,CAAC;AACf,MAAI,QAAQ;AAEZ,MAAI,WAAW,OAAO,QAAQ,OAAO,MAAM;AACzC,YAAQ,KAAK,IAAI,KAAK,IAAI,KAAK,EAAE,GAAG,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;AAC3D,YAAQ,QAAQ;AAAA,EAClB,OAAO;AACL,YAAQ,OAAO,QAAQ,OAAO,OAAO,IAAI,KAAK;AAAA,EAChD;AAEA,QAAM,IAAI;AACV,QAAM,IAAI,GAAG,CAAC,MAAM,QAAQ,GAAG,CAAC,MAAM,OAAO,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AAC7D,QAAM,IAAI,GAAG,CAAC,MAAM,QAAQ,GAAG,CAAC,MAAM,OAAO,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AAE7D,SAAO,KAAK,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC;AACxC;AAQO,IAAM,aAAN,MAAiB;AAAA,EAOtB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA,oBAAoB;AAAA,EACtB,IAA0B,CAAC,GAAG;AAV9B,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,QAAiB,CAAC,GAAG,GAAG,CAAC;AAChC,SAAQ,qBAAqB;AAO3B,SAAK,qBAAqB;AAC1B,SAAK,gBAAgB,EAAE,KAAK,OAAO,kBAAkB,CAAC;AAAA,EACxD;AAAA,EAEA,gBAAgB;AAAA,IACd;AAAA,IACA;AAAA,IACA,oBAAoB;AAAA,EACtB,GAAyB;AACvB,SAAK,qBAAqB;AAC1B,QAAK,OAAO,SAAW,CAAC,OAAO,CAAC,OAAQ;AACtC,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE,WAAW,KAAK;AACd,WAAK,IAAI,IAAI,CAAC;AACd,WAAK,IAAI,IAAI,CAAC;AACd,WAAK,IAAI,IAAI,CAAC;AACd,WAAK,QAAQ,WAAW,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,iBAAiB;AAAA,IACrE,WAAW,OAAO;AAChB,WAAK,QAAQ;AACb,OAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,WAAW,OAAO,iBAAiB;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,IAAI,SAAS,CAAC,GAAG,GAAG,CAAC,GAAY;AAC/B,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,QAAQ;AAAA,MACX,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,MACvB,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,IAAI,WAAoB;AACtB,WAAO,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,EAChC;AAAA,EAEA,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,GAAY;AAC1B,SAAK,QAAQ,CAAC,GAAG,GAAG,CAAC;AACrB,KAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI;AAAA,MACzB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,IAAI,MAAe;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,SAAiB;AACnB,UAAM,CAAC,GAAG,GAAG,CAAC,IAAI,KAAK;AACvB,WAAO,OAAO,EAAE,QAAQ,CAAC,OAAO,IAAI,KAAK,QAAQ,CAAC,QAAQ,IAAI,KAAK;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,WAAmB;AACrB,UAAM,CAAC,GAAG,GAAG,CAAC,IAAI,KAAK;AACvB,WAAO,UAAU,IAAI,KAAK,QAAQ,CAAC,OAAO,IAAI,KAAK,QAAQ,CAAC,KAAK,EAAE;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,SAAiB;AACnB,UAAM,CAAC,GAAG,GAAG,CAAC,IAAI,KAAK;AACvB,WAAO,QAAQ,IAAI,KAAK,QAAQ,CAAC,OAAO,IAAI,KAAK,QAAQ,CAAC,KAAK,EAAE;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,kBAAkB,KAAc;AAClC,SAAK,qBAAqB;AAC1B,SAAK,QAAQ;AAAA,MACX,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,MACvB,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,IAAI,oBAA6B;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,SAAS,OAAqB;AAC5B,SAAK,MAAM,CAAC,KAAK,OAAO,KAAK,MAAM,CAAC,IAAI,UAAU;AAClD,KAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI;AAAA,MACzB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AACF;AAaO,IAAM,SAAN,MAAa;AAAA,EAoBlB,YACE;AAAA,IACE,eAAe,cAAc;AAAA,IAC7B,YAAY;AAAA,IACZ,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAAC;AAAA,EACF,IAAmB;AAAA,IACjB,cAAc,cAAc;AAAA,IAC5B,WAAW;AAAA,IACX,kBAAkB;AAAA,IAClB,YAAY;AAAA,EACd,GACA;AA/BF,SAAQ,qBAAqB;AAC7B,SAAQ,qBAAqB;AAC7B,SAAQ,qBAAqB;AAI7B,SAAQ,4BAA4B;AAEpC,SAAQ,kBAAiC;AAEzC,SAAQ,qBAAqB;AAE7B,SAAQ,iBAAiB;AAoBvB,QAAI,CAAC,gBAAgB,aAAa,SAAS,GAAG;AAC5C,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAEA,SAAK,gBAAgB,aAAa;AAAA,MAChC,CAAC,UAAU,IAAI,WAAW,EAAE,OAAO,OAAO,kBAAkB,CAAC;AAAA,IAC/D;AAEA,SAAK,aAAa,YAAY;AAE9B,SAAK,qBACH,qBAAqB,oBAAoB;AAC3C,SAAK,qBACH,qBAAqB,oBAAoB;AAC3C,SAAK,qBACH,qBAAqB,oBAAoB;AAE3C,SAAK,4BAA4B,cAAc;AAE/C,SAAK,qBAAqB,qBAAqB;AAE/C,SAAK,iBAAiBA,kBAAiB;AAEvC,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,YAAoB;AAC7B,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,IAAW,UAAU,WAAmB;AACtC,QAAI,YAAY,GAAG;AACjB,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAChD;AACA,SAAK,aAAa,YAAY;AAC9B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,iBACT,kBACA;AACA,QAAI,MAAM,QAAQ,gBAAgB,GAAG;AACnC,UAAI,iBAAiB,WAAW,GAAG;AACjC,cAAM,IAAI,MAAM,8CAA8C;AAAA,MAChE;AACA,UACE,OAAO,iBAAiB,CAAC,MAAM,cAC/B,OAAO,iBAAiB,CAAC,MAAM,cAC/B,OAAO,iBAAiB,CAAC,MAAM,YAC/B;AACA,cAAM,IAAI,MAAM,+CAA+C;AAAA,MACjE;AACA,WAAK,qBAAqB,iBAAiB,CAAC;AAC5C,WAAK,qBAAqB,iBAAiB,CAAC;AAC5C,WAAK,qBAAqB,iBAAiB,CAAC;AAAA,IAC9C,OAAO;AACL,WAAK,qBAAqB;AAC1B,WAAK,qBAAqB;AAC1B,WAAK,qBAAqB;AAAA,IAC5B;AAEA,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,mBAA0D;AAEnE,QACE,KAAK,uBAAuB,KAAK,sBACjC,KAAK,uBAAuB,KAAK,oBACjC;AACA,aAAO,KAAK;AAAA,IACd;AAEA,WAAO;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,IAAW,kBAAkB,mBAAqC;AAChE,SAAK,qBAAqB;AAC1B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,oBAAsC;AAC/C,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,kBAAkB,mBAAqC;AAChE,SAAK,qBAAqB;AAC1B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,oBAAsC;AAC/C,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,kBAAkB,mBAAqC;AAChE,SAAK,qBAAqB;AAC1B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,oBAAsC;AAC/C,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,gBAAyB;AAClC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,cAAc,OAAgB;AACvC,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,IAAW,eAA6B;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,aAAa,cAA4B;AAClD,SAAK,gBAAgB;AACrB,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEO,oBAA0B;AAC/B,SAAK,eAAe,CAAC;AAErB,UAAM,qBAAqB,KAAK,4BAC5B,KAAK,aAAa,SAClB,KAAK,aAAa,SAAS;AAE/B,aAAS,IAAI,GAAG,IAAI,oBAAoB,KAAK;AAC3C,YAAM,OAAO;AAAA,QACX,KAAK,aAAa,CAAC;AAAA,QACnB,KAAK,cAAc,IAAI,KAAK,KAAK,aAAa,MAAM;AAAA,MACtD;AAEA,WAAK,aAAa,KAAK,IAAI;AAAA,IAC7B;AAEA,SAAK,SAAS,KAAK,aAAa,IAAI,CAAC,MAAM,MAAM;AAC/C,YAAM,aAAa,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE,WAAY,CAAC,GAAG,GAAG,CAAC;AACzD,YAAM,aAAa,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE,WAAY,CAAC,GAAG,GAAG,CAAC;AAIzD,YAAM,mBAAmB,KAAK,2BAA2B,CAAC;AAE1D,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,KAAK;AAAA,QACL,mBAAmB,OAAO;AAAA,QAC1B,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACP,EAAE;AAAA,QACA,CAAC,MACC,IAAI,WAAW,EAAE,KAAK,GAAG,mBAAmB,KAAK,mBAAmB,CAAC;AAAA,MACzE;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEO,eAAe;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAGe;AACb,QAAI,WAAW;AACf,UAAM,cAAc,wBAAS,KAAK;AAClC,QAAI,eAAe,KAAK;AACtB,YAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAClB,YAAM,CAAC,IAAI,EAAE,IAAI,cAAc,GAAG,CAAC;AACnC,iBAAW,CAAC,IAAI,IAAI,CAAC;AAAA,IACvB;AACA,UAAM,YAAY,IAAI,WAAW;AAAA,MAC/B,KAAK;AAAA,MACL;AAAA,MACA,mBAAmB,KAAK;AAAA,IAC1B,CAAC;AACD,QAAI,kBAAkB,QAAW;AAC/B,WAAK,aAAa,OAAO,eAAe,GAAG,SAAS;AAAA,IACtD,OAAO;AACL,WAAK,aAAa,KAAK,SAAS;AAAA,IAClC;AACA,SAAK,kBAAkB;AACvB,WAAO;AAAA,EACT;AAAA,EAEO,kBAAkB;AAAA,IACvB;AAAA,IACA;AAAA,EACF,GAGS;AACP,QAAI,CAAC,SAAS,UAAU,QAAW;AACjC,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,QAAI,KAAK,aAAa,SAAS,GAAG;AAChC,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAEA,QAAI;AAEJ,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,IACT,WAAW,OAAO;AAChB,aAAO,KAAK,aAAa,QAAQ,KAAK;AAAA,IACxC;AAEA,QAAI,OAAO,MAAM,OAAO,KAAK,aAAa,QAAQ;AAChD,WAAK,aAAa,OAAO,MAAM,CAAC;AAChC,WAAK,kBAAkB;AAAA,IACzB,OAAO;AACL,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AAAA,EACF;AAAA,EAEO,kBAAkB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIsC;AACpC,QAAI,eAAe,QAAW;AAC5B,cAAQ,KAAK,aAAa,UAAU;AAAA,IACtC;AAEA,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,QAAI,CAAC,OAAO,CAAC,OAAO;AAClB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAEA,QAAI,KAAK;AACP,YAAM,cAAc,wBAAS,KAAK;AAClC,UAAI,aAAa;AACf,cAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAClB,cAAM,CAAC,IAAI,EAAE,IAAI,cAAc,GAAG,CAAC;AACnC,cAAM,WAAW,CAAC,IAAI,IAAI,CAAC;AAAA,MAC7B,OAAO;AACL,cAAM,WAAW;AAAA,MACnB;AAAA,IACF;AACA,QAAI;AAAO,YAAM,MAAM;AAEvB,SAAK,kBAAkB;AAEvB,WAAO;AAAA,EACT;AAAA,EAEO,sBAAsB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,cAAc;AAAA,EAChB,GAIsB;AACpB,QAAI,CAAC,OAAO,CAAC,KAAK;AAChB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,QAAI;AAEJ,QAAI,KAAK;AACP,kBAAY,KAAK,aAAa;AAAA,QAAI,CAAC,WACjC,SAAS,OAAO,UAAU,GAAG;AAAA,MAC/B;AAAA,IACF,WAAW,KAAK;AACd,kBAAY,KAAK,aAAa;AAAA,QAAI,CAAC,WACjC,SAAS,OAAO,KAAK,KAAK,IAAI;AAAA,MAChC;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,IAAI,GAAG,SAAS;AAEzC,QAAI,cAAc,aAAa;AAC7B,aAAO;AAAA,IACT;AAEA,UAAM,qBAAqB,UAAU,QAAQ,WAAW;AAExD,WAAO,KAAK,aAAa,kBAAkB,KAAK;AAAA,EAClD;AAAA,EAEA,IAAW,WAAW,WAAoB;AACxC,SAAK,4BAA4B;AACjC,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,aAAsB;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,kBAAkB,WAAoB;AAC/C,SAAK,qBAAqB;AAC1B,SAAK,aAAa,QAAQ,CAAC,MAAO,EAAE,oBAAoB,SAAU;AAClE,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,IAAW,oBAA6B;AACtC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,IAAW,kBAAkB;AAC3B,WAAO,KAAK,OACT,KAAK,EACL,OAAO,CAAC,GAAG,MAAO,KAAK,IAAI,IAAI,KAAK,aAAa,IAAK;AAAA,EAC3D;AAAA,EAEA,IAAW,SAAS;AAClB,UAAM,SAAS,KAAK,gBAAgB,IAAI,CAAC,MAAM,EAAE,KAAK;AACtD,QAAI,KAAK,6BAA6B,KAAK,cAAc,WAAW,GAAG;AACrE,aAAO,IAAI;AAAA,IACb;AACA,WAAO;AAAA,EACT;AAAA,EAEO,UAAU,OAAgC,OAAiB;AAChE,UAAM,UAA2B;AAAA,MAC/B,KAAK,CAAC,MAA0B,EAAE;AAAA,MAClC,OAAO,CAAC,MAA0B,EAAE;AAAA,MACpC,KAAK,CAAC,MAA0B,EAAE;AAAA,IACpC;AACA,UAAM,YAAY,KAAK,gBAAgB,IAAI,QAAQ,IAAI,CAAC;AACxD,QAAI,KAAK,2BAA2B;AAClC,gBAAU,IAAI;AAAA,IAChB;AACA,WAAO;AAAA,EACT;AAAA,EAEA,IAAW,YAAY;AACrB,WAAO,KAAK,UAAU,KAAK;AAAA,EAC7B;AAAA,EAEA,IAAW,eAAe;AACxB,WAAO,KAAK,UAAU,KAAK;AAAA,EAC7B;AAAA,EAEA,IAAW,iBAAiB;AAC1B,WAAO,KAAK,UAAU,OAAO;AAAA,EAC/B;AAAA,EAEO,SAAS,SAAS,IAAU;AACjC,SAAK,aAAa,QAAQ,CAAC,MAAM,EAAE,SAAS,MAAM,CAAC;AACnD,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,WAAW,GAAuB;AAr0B3C;AAs0BI,QAAI,IAAI,KAAK,IAAI,GAAG;AAClB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAEA,QAAI,KAAK,aAAa,WAAW,GAAG;AAClC,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AAGA,UAAM,gBAAgB,KAAK,4BACvB,KAAK,aAAa,SAClB,KAAK,aAAa,SAAS;AAI/B,UAAM,oBACJ,KAAK,6BAA6B,KAAK,aAAa,WAAW,IAC3D,IACA;AAGN,UAAM,kBAAkB,IAAI;AAC5B,UAAM,eAAe,KAAK,MAAM,eAAe;AAC/C,UAAM,SAAS,kBAAkB;AAGjC,UAAM,qBACJ,gBAAgB,oBAAoB,oBAAoB,IAAI;AAC9D,UAAM,eAAe,gBAAgB,oBAAoB,IAAI;AAG7D,UAAM,OAAO,KAAK,aAAa,kBAAkB;AACjD,QAAI,CAAC,QAAQ,KAAK,SAAS,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG;AAEpD,aAAO,IAAI,WAAW;AAAA,QACpB,SAAO,UAAK,aAAa,CAAC,MAAnB,mBAAsB,UAAS,CAAC,GAAG,GAAG,CAAC;AAAA,QAC9C,mBAAmB,KAAK;AAAA,MAC1B,CAAC;AAAA,IACH;AAEA,UAAM,aAAa,KAAK,CAAC,EAAE;AAC3B,UAAM,aAAa,KAAK,CAAC,EAAE;AAG3B,UAAM,mBACJ,KAAK,2BAA2B,kBAAkB;AAGpD,UAAM,MAAM;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAEA,WAAO,IAAI,WAAW;AAAA,MACpB;AAAA,MACA,mBAAmB,KAAK;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,2BAA2B,cAA+B;AAChE,WAAO,CAAC,EACN,eAAe,KACd,KAAK,6BACJ,KAAK,aAAa,WAAW,KAC7B,iBAAiB;AAAA,EAEvB;AACF;AAGA,IAAM,EAAE,GAAG,IAAI;AAEf,IAAI,MAAM,GAAG,WAAW,GAAG,QAAQ,WAAW,IAAI,GAAG;AACnD,UAAQ,KAAK,kDAAkD;AAE/D,QAAM,SAAS,IAAI,OAAO;AAC1B,KAAG,UAAU,SAAS;AAEtB,QAAM,eAAe,MACnB,OAAO,OAAO;AAAA,IACZ,CAAC,MAAM,OAAO,KAAK,MAAM,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,IAAI;AAAA,EAC1D;AAEF,KAAG,UAAU,eAAe,gBAAgB,YAAY;AAExD,aAAW,SAAS;AACpB,aAAW,eAAe;AAC5B;",
  "names": ["t", "invert", "clampToCircle"]
}
